<!--Title={Binary Heap: percDown(), minChild(), and delMin()}-->

<!--badges={Algorithms:15,Python:5}-->

<!--concepts={Binary Search Tree Heap}-->

With the `insert` method properly defined, we can now look at the `delMin` method. Since the heap property requires that the root of the tree be the smallest item in the tree, finding the minimum item is easy. The hard part of `delMin` is restoring full compliance with the heap structure and heap order properties after the root has been removed. We can restore our heap in two steps. First, we will restore the root item by taking the last item in the list and moving it to the root position. Moving the last item maintains our heap structure property. However, we have probably destroyed the heap order property of our binary heap. As such, we will then restore the heap order property by percolating the new root node *down* the tree to its proper position. Below shows the series of swaps needed to move the new root node to its proper position in the heap:

![](https://runestone.academy/runestone/books/published/pythonds/_images/percDown.png)

> Figure 3: Percolating the Root Node down the Tree



In order to maintain the heap order property, all we need to do is swap the root with its smallest child smaller than the root. After the initial swap, we may repeat the swapping process with a node and its children until the node is in a place where it is already smaller than both children. The code for percolating a node down the tree is found in the `percDown` and `minChild` methods as seen below:

```python
def minChild(self,i):
    if i * 2 + 1 > self.currentSize:
        return i * 2
    else:
        if self.heapList[i*2] < self.heapList[i*2+1]:
            return i * 2
        else:
            return i * 2 + 1
```

We will first define `minChild`, which is the helper method that our main `percDown` function will utilize. The goal of this method is to find the current node's smallest child. It does this using 2 checks. First, it checks to see if the current node doesn't have a right child. In other words, is the node's left child the last node in the tree. (Remember how we talked about how you can find the index of a parent node by dividing the child node's index by 2. The inverse also works, except we multiply by 2 to find the child node's index). If so, then it returns the left child as the smallest child. If not, it checks to see which is the smaller of the two children. It returns the index of the smaller child.

```python
def percDown(self,i):
    while (i * 2) <= self.currentSize:
        mc = self.minChild(i)
        if self.heapList[i] > self.heapList[mc]:
            tmp = self.heapList[i]
            self.heapList[i] = self.heapList[mc]
            self.heapList[mc] = tmp
        i = mc
```

Here is where we define the main `percDown` method. The while loop condition states that we keep running the process as long as we haven't reached the end of the tree. We first set `mc` to the index of the current node's smallest child, via `minChild`. Then, we do the same swapping routine as we saw in `percUp` earlier, except this time we swap if the current node is *larger*. Finally, we set the index of the current node to the index of its smallest child, before repeating the process once more.

The code for the `delmin` operation is defined below. Note that once again the hard work is handled by a helper function, in this case `percDown`.

```python
def delMin(self):
    retval = self.heapList[1]
    self.heapList[1] = self.heapList[self.currentSize]
    self.currentSize = self.currentSize - 1
    self.heapList.pop()
    self.percDown(1)
    return retval
```

